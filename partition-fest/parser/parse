type srcloc = string * int
fun srclocString (source, line) = source ^ ", line " ^ Int.toString line

type token = char list
fun isLiteral s t = s = (implode t)

datatype 'a susp_contents = THUNK of unit -> 'a
                          | FORCED of 'a
type 'a susp = 'a susp_contents ref
fun delay f = ref (THUNK f)
fun force cell = 
  case !cell
    of THUNK f => let val v = f() in v before cell := FORCED v end
     | FORCED v => v
fun suspendedValue cell =
  case !cell
    of THUNK f  => NONE
     | FORCED v => SOME v

datatype 'a llist = ::: of 'a * 'a llist
                  | NEED_MORE of 'a llist susp
infixr 3 :::
fun fromLazy (h ::: t) = h :: fromLazy t
  | fromLazy (NEED_MORE l) =
        case suspendedValue l of SOME l1 => fromLazy l1
                               | NONE    => []
fun toLazy more items = 
  foldr op ::: (NEED_MORE (delay (fn () => toLazy more (more())))) items

fun lforce (NEED_MORE t) = lforce (force t)
  | lforce tokens        = tokens


exception SyntaxError of string

type 'a parser = (srcloc * token) llist -> 'a * (srcloc * token) llist

exception E of string * string * (srcloc * token) llist

infix 0 ||
fun (p1 || p2) toks = p1 toks handle E _ => p2 toks

fun !! p tokens =
  p tokens handle E (nt, why, tokens) => raise SyntaxError "problem"

infix 5 --
fun (p1 -- p2) tokens = 
  let val (x, tokens) = p1 tokens
      val (y, tokens) = p2 tokens
  in ((x, y), tokens)
  end

fun triple f ((x, y), z) = f (x,y,z)

fun fail nt why toks = raise E (nt, why, toks)

fun singleToken tokens = 
  case lforce tokens
    of t ::: tokens => (t, tokens)
     | NEED_MORE _  => raise SyntaxError "unexpected end of file"

fun inDomain nt msg map = 
  let val bad = fail nt msg
      fun try (t, tokens) = case map (#2 t) of NONE => bad (t:::tokens)
                                             | SOME a => (a, tokens)
  in fn tokens => (try (singleToken tokens))
     handle EOF => raise E (nt, "end of file", tokens)
  end

fun literal s =
  inDomain "literal" ("Expecting " ^ s)
  (fn  t => if isLiteral s t then SOME () else NONE)

infix 2 >>
fun (p >> f) tokens = 
  let val (x, tokens) = p tokens
  in (f x, tokens)
  end

infix  6 --<
infixr 7 >--
fun (a >-- p) = (literal a -- p >> #2)
fun (p --< a) = (p -- literal a >> #1)

infix  6 --$
infixr 7 $--
fun (a $-- p) = (literal a -- !!p >> #2)
fun (p --$ a) = (p -- !!(literal a) >> #1)

fun nothingAs v tokens = (v, tokens)
fun repeat p tokens =
  (p -- (repeat p o lforce) >> op :: || nothingAs []) tokens
fun manySep separator p tokens = 
  (p -- (separator $-- (manySep separator p o lforce) || nothingAs []) >> op ::) tokens

fun optional p = p >> SOME || nothingAs NONE

type reader = {firstLine : unit -> string,
               nextLine  : unit -> string,
               curloc    : unit -> string * int }

exception EOF
fun fileReader (filename, fd)=
  let val lineNum = ref 0
      fun get () = 
       case TextIO.inputLine fd
         of NONE      => raise EOF
          | SOME line => line before lineNum := !lineNum + 1
  in { firstLine = get, nextLine = get, 
       curloc = (fn () => (filename, !lineNum)) }
  end